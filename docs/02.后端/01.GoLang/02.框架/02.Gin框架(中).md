---
title: Gin框架(中)
date: 2023-02-14 22:25:10
permalink: /pages/bb4f5d/

---

## Gin渲染

### 模板操作

#### pipeline

`pipeline`是指产生数据的操作。比如`{{.}}`、`{{.Name}}`等。Go的模板语法中支持使用管道符号`|`链接多个命令，用法和unix下的管道类似：`|`前面的命令会将运算结果(或返回值)传递给后一个命令的最后一个位置。

**注意：**并不是只有使用了`|`才是pipeline。Go的模板语法中，`pipeline的`概念是传递数据，只要能产生数据的，都是`pipeline`。

#### 变量

```go
===hello.tmpl
$v1={{.}}
```

#### 移除空格

```go
{{- .Name -}}
```

`- 紧挨{}`

#### 条件判断

if与end 配套使用

```go
{{if xxxx}} xxx {{end}}
{{if xxxx}} xxx {{else}} xxx {{end}}
{{if xxxx}} xxx  {{else if xxx}} xxx {{end}}
```

#### range

```go
{{range pipeline}} T1 {{end}}
//pipeline 为空 就执行T0
{{range pipeline}} T1 {{else}} T0 {{end}}

{{range $idx,$value:=pipeline}}
T1
{{end}}
```

#### with

```go
<p>.m1.gender</p>

{{with .m1}}
//使得此时.=.m1
<p>.gender</p>
{{end}}
```

#### 比较函数

```go
布尔函数会将任何类型的零值视为假，其余视为真。

下面是定义为函数的二元比较运算的集合：

eq      如果arg1 == arg2则返回真
ne      如果arg1 != arg2则返回真
lt      如果arg1 < arg2则返回真
le      如果arg1 <= arg2则返回真
gt      如果arg1 > arg2则返回真
ge      如果arg1 >= arg2则返回真
为了简化多参数相等检测，eq（只有eq）可以接受2个或更多个参数，它会将第一个参数和其余参数依次比较，返回下式的结果：

{{eq arg1 arg2 arg3}}
比较函数只适用于基本类型（或重定义的基本类型，如”type Celsius float32”）。但是，整数和浮点数不能互相比较。
```

#### 预定义函数

```go
and
    函数返回它的第一个empty参数或者最后一个参数；
    就是说"and x y"等价于"if x then y else x"；所有参数都会执行；
or
    返回第一个非empty参数或者最后一个参数；
    亦即"or x y"等价于"if x then x else y"；所有参数都会执行；
not
    返回它的单个参数的布尔值的否定
len
    返回它的参数的整数类型长度
index
    执行结果为第一个参数以剩下的参数为索引/键指向的值；
    如"index x 1 2 3"返回x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。
print
    即fmt.Sprint
printf
    即fmt.Sprintf
println
    即fmt.Sprintln
html
    返回与其参数的文本表示形式等效的转义HTML。
    这个函数在html/template中不可用。
urlquery
    以适合嵌入到网址查询中的形式返回其参数的文本表示的转义值。
    这个函数在html/template中不可用。
js
    返回与其参数的文本表示形式等效的转义JavaScript。
call
    执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数；
    如"call .X.Y 1 2"等价于go语言里的dot.X.Y(1, 2)；
    其中Y是函数类型的字段或者字典的值，或者其他类似情况；
    call的第一个参数的执行结果必须是函数类型的值（和预定义函数如print明显不同）；
    该函数类型值必须有1到2个返回值，如果有2个则后一个必须是error接口类型；
    如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误；
```



#### 自定义函数

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "text/template"
)

type User struct {
    Name string
}

func sayhello(w http.ResponseWriter, r *http.Request) {
    file, err := ioutil.ReadFile("./hello.tmpl")
    if err != nil {
        fmt.Println("read html failed :", err)
        return
    }
    //要么只有一个返回值,要么就有两个第二个必须是error
    kua := func(arg string) (string, error) {
        return arg + "真帅", nil
    }
    parse, err := 
   //创建一个名为hello模板对象 
    //解析模板注册一个新的模板函数
   template.New("hello").Funcs(template.FuncMap{"kua": kua}).Parse(string(file))
    if err != nil {
        fmt.Println("parse failed :	", err)
        return
    }

    user := User{
        Name: "zqy",
    }

    parse.Execute(w, user)

}

func main() {
    http.HandleFunc("/", sayhello)
    err := http.ListenAndServe(":9090", nil)
    if err != nil {
        fmt.Println("failed :", err)
        return
    }
}

```

#### 嵌套模板

```go
<!DOCTYPE html>
<html lang="en">
<head>
<!--    -->
<meta charset="UTF-8">
<title>Title</title>
</head>
<body>
{{template "ut.tmpl"}}
{{template "o1.tmpl"}}
</body>
</html>

{{ define "o1.tmpl"}}
<ol>
<li>hello</li>
</ol>
{{end}}

===========
func demo(w http.ResponseWriter, r *http.Request) {
    //先渲染父模板,后子模板
    files, err := template.ParseFiles("./hello.tmpl", "./ut.tmpl")

    if err != nil {
        fmt.Println("parse failed :", err)
        return
    }
    files.Execute(w, nil)
}
func main() {
    http.HandleFunc("/", sayhello)
    http.HandleFunc("/hello", demo)
    err := http.ListenAndServe(":9090", nil)
    if err != nil {
        fmt.Println("failed :", err)
        return
    }
}
```



#### 模板继承

>  block

定义初始模板`base.tmpl`

```go
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>Go Templates</title>
</head>
<style>
    .container-fluid{
        background-color: red;
    }
</style>
<body>
<div class="container-fluid">
	//使用block 设置根模板
    {{block "content" . }}{{end}}
</div>
</body>
</html>
```

定义子模板`index.tmpl`

```go
// 继承根模板
{{template "base.tmpl" .}}

//重新定义块模块
{{define "content"}}
//填充到根模板里面的.  传入参数首先是传到根模板里面,所以如果不在上面template里面加上.,就无法得到传进去的参数
<div>Hello world!{{.}}</div>
{{end}}
```

解析模板

```go
func index(w http.ResponseWriter, r *http.Request) {
	tmpl, err := template.ParseGlob("./*.tmpl")
	if err != nil {
		fmt.Println("create template failed, err:", err)
		return
	}
	err = tmpl.ExecuteTemplate(w, "index.tmpl", nil)
	if err != nil {
		fmt.Println("render template failed, err:", err)
		return
	}
}
```



> 如果我们的模板名称冲突了，例如不同业务线下都定义了一个`index.tmpl`模板，我们可以通过下面两种方法来解决。
>
> 1. 在模板文件开头使用`{{define 模板名}}`语句显式的为模板命名。
> 2. 可以把模板文件存放在`templates`文件夹下面的不同目录中，然后使用`template.ParseGlob("templates/**/*.tmpl")`解析模板。



### 原生模板渲染

模板语言都包含在`{{}} `

`hello.tmpl`

```go
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Title</title>
</head>
<body>
//{{.}}占位符
<p>Hello{{.}}</p>
</body>
```



```go
package main

import (
    "fmt"
    "net/http"
    "text/template"
)

func sayhello(w http.ResponseWriter, r *http.Request) {
    //2.解析模板
    files, err := template.ParseFiles("./hello.tmpl")
    if err != nil {
        fmt.Println("parse files failed:", err)
        return
    }

    //3.渲染模板   "java" 会传递给tmpl模板里面的{{.}}
    err = files.Execute(w, "java")
    if err != nil {
        fmt.Println("execute failed:", err)
        return
    }

}
func main() {
    http.HandleFunc("/", sayhello)

    err := http.ListenAndServe(":9090", nil)
    if err != nil {
        fmt.Println("no")
        return
    }
}


//注意一个goland不要直接右键运行,因为不确定go build路径,导致上述./hello.tmpl 相对路径错误

所以建议使用命令行进入所在文件go build xx 


也可以传入结构体,map等数据结构
type Userinfo struct {
    Id   string
    name string
    age  int
}
user := Userinfo{
    Id:   "123",
    name: "zqy",
    age:  12,
}
m1 := map[string]interface{}{
    "Name": "zqy",
}
err = files.Execute(w, map[string]interface{}{
    "m1":   m1,
    "user": user,
})
可以{{.m1.Name}}

并且前端可选字段渲染 {{.Id}} //注意go里面字段首字母大写表示公开,如果是小写,那么就无法读取数据
```

### HTML渲染

我们首先定义一个存放模板文件的`templates`文件夹，然后在其内部按照业务分别定义一个`posts`文件夹和一个`users`文件夹。 `posts/index.html`文件的内容如下：

```template
{{define "posts/index.html"}}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>posts/index</title>
</head>
<body>
    {{.title}}
</body>
</html>
{{end}}
```

`users/index.html`文件的内容如下：

```template
{{define "users/index.html"}}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>users/index</title>
</head>
<body>
    {{.title}}
</body>
</html>
{{end}}
```

Gin框架中使用`LoadHTMLGlob()`或者`LoadHTMLFiles()`方法进行HTML模板渲染。

```go
func main() {
	r := gin.Default()
	r.LoadHTMLGlob("templates/**/*")
	//r.LoadHTMLFiles("templates/posts/index.html", "templates/users/index.html")
	r.GET("/posts/index", func(c *gin.Context) {
		c.HTML(http.StatusOK, "posts/index.html", gin.H{
			"title": "posts/index",
		})
	})

	r.GET("users/index", func(c *gin.Context) {
		c.HTML(http.StatusOK, "users/index.html", gin.H{
			"title": "users/index",
		})
	})

	r.Run(":8080")
}
```

### 自定义模板函数

定义一个不转义相应内容的`safe`模板函数如下：

```go
func main() {
	router := gin.Default()
	router.SetFuncMap(template.FuncMap{
		"safe": func(str string) template.HTML{
			return template.HTML(str)
		},
	})
	router.LoadHTMLFiles("./index.tmpl")

	router.GET("/index", func(c *gin.Context) {
		c.HTML(http.StatusOK, "index.tmpl", "<a href='https://liwenzhou.com'>李文周的博客</a>")
	})

	router.Run(":8080")
}
```

在`index.tmpl`中使用定义好的`safe`模板函数：

```template
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>修改模板引擎的标识符</title>
</head>
<body>
<div>{{ . | safe }}</div>
</body>
</html>
```

为了让index.tmpl文件有语法显示，我们还需要配置一下

![image-20200913213156919](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20200913213156919.png)

然后我们加入 *.tmpl，保存即可

### 静态文件处理

当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用`gin.Static`方法即可。

```go
func main() {
	r := gin.Default()
	r.Static("/static", "./static")
	r.LoadHTMLGlob("templates/**/*")
   // ...
	r.Run(":8080")
}
```

### 使用模板继承

Gin框架默认都是使用单模板，如果需要使用`block template`功能，可以通过`"github.com/gin-contrib/multitemplate"`库实现，具体示例如下：

首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中`home.tmpl`和`index.tmpl`继承了`base.tmpl`：

```bash
templates
├── includes
│   ├── home.tmpl
│   └── index.tmpl
├── layouts
│   └── base.tmpl
└── scripts.tmpl
```

然后我们定义一个`loadTemplates`函数如下：

```go
func loadTemplates(templatesDir string) multitemplate.Renderer {
	r := multitemplate.NewRenderer()
	layouts, err := filepath.Glob(templatesDir + "/layouts/*.tmpl")
	if err != nil {
		panic(err.Error())
	}
	includes, err := filepath.Glob(templatesDir + "/includes/*.tmpl")
	if err != nil {
		panic(err.Error())
	}
	// 为layouts/和includes/目录生成 templates map
	for _, include := range includes {
		layoutCopy := make([]string, len(layouts))
		copy(layoutCopy, layouts)
		files := append(layoutCopy, include)
		r.AddFromFiles(filepath.Base(include), files...)
	}
	return r
}
```

我们在`main`函数中

```go
func indexFunc(c *gin.Context){
	c.HTML(http.StatusOK, "index.tmpl", nil)
}

func homeFunc(c *gin.Context){
	c.HTML(http.StatusOK, "home.tmpl", nil)
}

func main(){
	r := gin.Default()
	r.HTMLRender = loadTemplates("./templates")
	r.GET("/index", indexFunc)
	r.GET("/home", homeFunc)
	r.Run()
}
```

### 补充文件路径处理

关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。

```go
func getCurrentPath() string {
	if ex, err := os.Executable(); err == nil {
		return filepath.Dir(ex)
	}
	return "./"
}
```

### JSON渲染

```go
func main() {
	r := gin.Default()

	// gin.H 是map[string]interface{}的缩写
	r.GET("/someJSON", func(c *gin.Context) {
		// 方式一：自己拼接JSON
		c.JSON(http.StatusOK, gin.H{"message": "Hello world!"})
	})
	r.GET("/moreJSON", func(c *gin.Context) {
		// 方法二：使用结构体
		var msg struct {
			Name    string `json:"user"`
			Message string
			Age     int
		}
		msg.Name = "小王子"
		msg.Message = "Hello world!"
		msg.Age = 18
		c.JSON(http.StatusOK, msg)
	})
	r.Run(":8080")
}
```

### XML渲染

注意需要使用具名的结构体类型。

```go
func main() {
	r := gin.Default()
	// gin.H 是map[string]interface{}的缩写
	r.GET("/someXML", func(c *gin.Context) {
		// 方式一：自己拼接JSON
		c.XML(http.StatusOK, gin.H{"message": "Hello world!"})
	})
	r.GET("/moreXML", func(c *gin.Context) {
		// 方法二：使用结构体
		type MessageRecord struct {
			Name    string
			Message string
			Age     int
		}
		var msg MessageRecord
		msg.Name = "小王子"
		msg.Message = "Hello world!"
		msg.Age = 18
		c.XML(http.StatusOK, msg)
	})
	r.Run(":8080")
}
```

### YMAL渲染

```go
r.GET("/someYAML", func(c *gin.Context) {
	c.YAML(http.StatusOK, gin.H{"message": "ok", "status": http.StatusOK})
})
```

### protobuf渲染

```go
r.GET("/someProtoBuf", func(c *gin.Context) {
	reps := []int64{int64(1), int64(2)}
	label := "test"
	// protobuf 的具体定义写在 testdata/protoexample 文件中。
	data := &protoexample.Test{
		Label: &label,
		Reps:  reps,
	}
	// 请注意，数据在响应中变为二进制数据
	// 将输出被 protoexample.Test protobuf 序列化了的数据
	c.ProtoBuf(http.StatusOK, data)
})
```

