---
title: RabbitMQ(更新中)
date: 2023-02-23 18:53:05
permalink: /pages/337fc2/
---
# RabbitMQ

## 1.MQ

### 1.1 介绍

> 相关概念

MQ(message queue)，从字面意思上看，本质是个队列，[FIFO](https://so.csdn.net/so/search?q=FIFO&spm=1001.2101.3001.7020)先入先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中,MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。



> 使用场景

<font color='red'>1.流量消峰</font>

订单系统最多处理1万次请求，但在高峰期，会出现超过限度的请求，此时如果全部接受，就会导致系统崩溃宕机。

`MQ`的作用就进行接受请求作为缓存，将一次性发送的请求，分批次传递给系统。

优点： 避免系统崩溃宕机

缺点：用户发送的请求可能会等很久才会收到结果

![image-20230223185311713](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223185311713.png)



<font color='red'>2.应用解耦</font>

![image-20230223185658725](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223185658725.png)

用户创建订单后，系统会进行一系列操作，如果某一个操作出了故障就会导致下单操作异常。使用`MQ`就将发生故障的操作数据存在队列当中，操作继续执行，等故障修复后，接着处理未完成的操作。

优点：操作者感知不到系统的故障，提升了系统的可用性

<font color='red'>3.异步处理</font>

![image-20230223190051622](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223190051622.png)

有些服务间是异步调用，比如A调用B。如果B需要很长时间执行，A需要知道执行结束时间，以前有两种方式。

一是A过段时间就去调用B的查询，查询B多久结束。

二是A提供一个callback（回调函数）api，当B执行完毕后就调用api通知A；

上面两种都要进行多余的操作，不够优雅。

使用`MQ`，B执行完后给`MQ`发送消息，然后再将结束信息转发给A。



### 1.2 MQ分类



1. `ActiveMQ`：

   - 优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据
   - 缺点：维护越来越少，高吞吐量场景较少使用

2. `Kafka`：大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件,以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输存储的过程中发挥着举足轻重的作用。目前已经被LinkedIn，Uber,Twitter,Netflix等大公司所采纳。

   - 优点：

     性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。时效性ms级可用性非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用Pull方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web管理界面Kafka-Manager;在日志领域比较成熟，被多家公司和多个开源项目使用;功能支持:功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用

   - 缺点：

     Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试;支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢;

3. `RocketMQ`：出自阿里巴巴的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理binglog分发等场
   景。

   - 优点：

     单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到0丢失,MQ功能较为完善，还是分布式的，扩展性好,支持10亿级别的消息堆积，不会因为堆积导致性能下降,源码是java我们可以自己阅读源码，定制自己公司的MQ

   - 缺点：

     支持的客户端语言不多，目前是java及c++，其中c++不成熟;社区活跃度一般,没有在MQ核心中去实现JMS等接口,有些系统要迁移需要修改大量代码

4. `RabbitMQ`：2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。

   - 优点：

     由于erlang语言的高并发特性，性能较好;吞吐量到万级，MQ功能比较完备,健壮、稳定、易用、跨平台、支持多种语言如: Python、Ruby、.NET、 Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX文档齐全;开源提供的管理界面非常棒，用起来很好用,社区活跃度高;
     更新频率相当高

   - 缺点：

     商业版需要收费,学习成本较高



### 1.3 选择

| MQ       | 介绍                                                         |
| -------- | ------------------------------------------------------------ |
| MQ       | 介绍                                                         |
| Kafka    | Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生`大量数据`的互联网服务的数据收集业务。`大型公司`建议可以选用，如果有`日志采集`功能,肯定是首选kafka了。 |
| RocketMQ | 天生为`金融互联网`领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。 |
| RabbitMQ | 结合erlang语言本身的并发优势，`性能好时效性微秒级`，`社区活跃度也比较高`，管理界面用起来十分方便，如果你的`数据量没有那么大`，中小型公司优先选择功能比较完备的RabbitMO |



## 2.RabbitMQ

### 2.1 介绍

> 概念

RabbitMQ是一个消息中间件:它接受并转发消息。它不处理信息，只负责**接受，存储，转发**。

> 四大核心概念

![image-20230223191225964](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223191225964.png)



| 概念   | 介绍                                                         |
| ------ | ------------------------------------------------------------ |
| 生产者 | 产生数据发送消息的程序是生产者                               |
| 交换机 | 对信息接受并处理。交换机需要知道对信息如何处理，推送单个队列或多个队列或丢弃，由交换机类型决定。 |
| 队列   | 存储信息的数据结构，仅受主机内容和磁盘限制，本质是一个大的消息缓冲区。多个生产者可以将消息发送一个队列中，多个消费者可以**尝试**从一个队列中获取信息，但**接收到的只有一个消费者。** |
| 消费者 | 消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件**很多时候并不在同一机器上**。同一个应用程序既可以是生产者又是可以是消费者。 |



### 2.2 核心部分

![image-20230223191844366](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223191844366.png)



| 部分         | 功能                                                         |
| ------------ | ------------------------------------------------------------ |
| Borker       | 接受和分发消息的应用，RabbitMQ Server就是Message Broker      |
| Connection   | publisher / consumer和broker之间的TCP连接                    |
| Channel      | 如果每一次访问 RabbitMQ 都建立一个Connection，在消息量大的时候建立TCPConnection的开销将是巨大的，效率也较低。Channel是在connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread 创建单独的channel进行通讯，AMQP method包含了channel id 帮助客户端和message broker识别 channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。每次发消息只会占用**一个**channel，发多次消息 |
| Virtual host | 每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的connection、exchange、queue、binding等，拥有自己的权限。vhost之于RabbitMQ就像虚拟机于物理机一样，他们通过在各个实例间提供逻辑上分离，允许为不同的应用程序安全保密的运行数据。 |
| Exchange     | message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有: direct (point-to-point), topic (publish-subscribe) and fanout (multicast) |
| Queue        | 消息最终被送到这里等到consumer取走                           |
| Binding      | exchange和queue之间的虚拟连接，binding中可以包含routing key，**Binding消息被保存到exchange中的查询表中**，用于message的分发依据 |

### 2.3 安装

笔者在ubuntu下学习

[ubuntu下](https://zhuanlan.zhihu.com/p/545276968)

```sh

# 查看状态
systemctl status rabbitmq-server

# 启动
systemctl start rabbitmq-server
# 停止
systemctl stop rabbitmq-server

#安装可视化管理 插件
rabbitmq-plugins enable rabbitmq_management
http://localhost:15672/

初始化账号和密码 guest

# 创建账号
rabbitmqctl add_user admin 123

# 设置用户角色
rabitmqctl set_user_tags admin adminstrator

# 设置用户权限
set_permissions[-p ,<vhostpath>]<user><config><write><read>
rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"

# 查看用户列表
rabbitmqctl list_users
```

![image-20230223194123458](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223194123458.png)



![image-20230223194512644](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223194512644.png)



### 2.4 Java环境

maven工程下

> 准备

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.8.0</version>
</dependency>

<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.6</version>
</dependency>
```

#### 2.4.1 案例一

![image-20230223195559882](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223195559882.png)

##### 生产者代码

```java
package RabbitMQ.Day1;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:生产者
 * @ClassName:Producer
 */

public class Producer {

    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        //        创建连接工厂
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 设置连接RabbitMQ的IP
        connectionFactory.setHost("localhost");
        // 用户名
        connectionFactory.setUsername("guest");
        //密码
        connectionFactory.setPassword("guest");
        //端口
        connectionFactory.setPort(5672);
        //创建连接
        Connection connection = connectionFactory.newConnection();
        //创建通道
        Channel channel = connection.createChannel();

        /**
         * 生成队列
         * 参数1 队列名
         * 参数2：队列里面的消息是否持久化，默认情况下，消息存储在内存中
         * 参数3：该队列是否只供一个消费者进行消费，是否进行消费共享，true可以多个消费者消费，
         *     false只能一个消费者消费
         * 参数4：是否自动删除：最后一个消费者断开连接之后，该队列是否自动删除，true则自动删除，
         *    false不自动删除
         * 参数5：其他参数
         */
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        //发送消息
        String message = "hello,world";

        /*
         * 发送一个消息
         * 参数1：发送到哪个交换机
         * 参数2：路由的key值是那个，本次是队列的名称
         * 参数3：其他参数信息
         * 参数4：发送消息的消息体
         * */
        channel.basicPublish("", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));

        System.out.println("消息发送完毕！");
    }

}

```



##### 消费者代码

```java
package RabbitMQ.Day1;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:消费者
 * @ClassName:Consumer
 */

public class Consumer {

    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 设置连接RabbitMQ的IP
        connectionFactory.setHost("localhost");
        // 用户名
        connectionFactory.setUsername("guest");
        //密码
        connectionFactory.setPassword("guest");
        //端口
        connectionFactory.setPort(5672);
        //创建连接
        Connection connection = connectionFactory.newConnection();
        //创建通道
        Channel channel = connection.createChannel();

        // 声明 接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            System.out.println(new String(message.getBody()));
        };

        //声明 取消消息
        CancelCallback cancelCallback = consumer -> {
            System.out.println("消息被中断");
        };



        /*
         * 消费者接收消息
         * 参数1：表示消费哪个队列
         * 参数2：消费成功之后，是否需要自动应答，true表示自动应答，false表示手动应答
         * 参数3：消费者成功消费的回调
         * 参数4：消费者取消消费的回调
         */
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}

```



## 3. workqueue（工作队列）

主要思想避免立即执行任务，而当前进程必须等待完成。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。

（采取轮询策略，一个线程得到任务，就访问下一个工作线程）

![image-20230223202415004](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223202415004.png)



### 3.1 轮训分发消息

##### 工作线程代码

```java
package RabbitMQ.WorkQueue;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Worker01
 */

public class Worker01 {
    // 队列名称
    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        // 接受消息参数
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            System.out.println("接受到的消息：" + new String(message.getBody()));
        };

        // 取消消费参数
        CancelCallback cancelCallback = consumerTag -> {
            System.out.println(consumerTag + "消费者取消消费借口回调逻辑");
        };

        System.out.println("C1等待接受消息.....");

        // 消息的接受
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}

```



在IDEA里面进行设置，程序开启多进程

![image-20230223203145922](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223203145922.png)





##### 生产者代码

```java
package RabbitMQ.WorkQueue;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class Producer {
    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            System.out.println("发送消息完成:" + message);
        }
    }
}

```

##### 结果

![image-20230223204628022](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223204628022.png)



![image-20230223204654090](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223204654090.png)



![image-20230223204700890](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223204700890.png)



**轮询效果**



### 3.2 消息应答

#### 概念

为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制，消息应答就是:消费者在接收到消息并且**处理该消息之后**，告诉RabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。



#### 自动应答

**消息发送后立即被认为已经传送成功**，这种模式需要在高吞吐量和数据传输安全性方面做权衡。如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了。并且没有对传递的消息数量进行限制，可能导致消费者来不及接受，导致信息堆积，使得内存耗尽，最终消费者线程被操作系统杀死。

**所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。**



#### 手动应答方法

1. Channel.basicAck(用于肯定确认)

   RabbitMQ已知道该消息并且成功处理，可以将其丢弃

2. Channel.basicNack(用于否定确认)

3. Channel.basicReject(用于否定确认)，与Channel.basicNack相比少了一个参数，不处理该消息了，直接拒绝，可以将其丢弃了。



> Multiple

手动应答的好处是`可以批量应答并且减少网络拥堵`

![image-20230223205841705](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223205841705.png)



multiple的true和false是不同的意思：

1. true表示批量应答channel上未应答的消息，比如channel上有传送tag的消息5,6,7,8,，当前tag是8，那么此时5-8的这些还未应答的消息就会被确认收到消息应答
2. false同上面相比**只会应答tag=8**的消息，5,6,7这三个消息依然不会被确认收到消息应答



#### 消息重新入队

> 如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将**了解到消息未完全处理，并将对其重新排队**。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。



![image-20230223210216401](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223210216401.png)



##### 生产者代码

```java
package RabbitMQ.ReplyMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class Producer {
    public static final String TASK_QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        // 声明队列
        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            channel.basicPublish("", TASK_QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println("生产者发出消息：" + message);
        }

    }
}

```



##### 消费者代码

```java
package RabbitMQ.ReplyMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static RabbitMQ.ReplyMessage.Producer.TASK_QUEUE_NAME;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Consumer
 */

public class Consumer {

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();
        System.out.println("C1等待接受消息处理时间较短");

        DeliverCallback deliverCallback = (consumerTag, message) -> {
            // 沉睡一秒
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {


            }
            System.out.println("接受到的消息是:"+new String(message.getBody()));

            //进行手动应答
            /*
             * 参数1：消息的标记  tag
             * 参数2：是否批量应答，false：不批量应答 true：批量
             * */
            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
        };


        // 采用手动应答
        boolean autoAck = false;
        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag) -> {
            System.out.println(consumerTag+"消费者取消消费接口回调逻辑");
        });
    }
}

```



```java
package RabbitMQ.ReplyMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static RabbitMQ.ReplyMessage.Producer.TASK_QUEUE_NAME;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Consumer1
 */

public class Consumer1 {
    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();
        System.out.println("C2等待接受消息处理时间较短");

        DeliverCallback deliverCallback = (consumerTag, message) -> {
            // 沉睡30秒
            try {
                TimeUnit.SECONDS.sleep(30);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("接受到的消息是:"+new String(message.getBody()));

            //进行手动应答
            /*
             * 参数1：消息的标记  tag
             * 参数2：是否批量应答，false：不批量应答 true：批量
             * */
            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
        };


        // 采用手动应答
        boolean autoAck = false;
        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag) -> {
            System.out.println(consumerTag+"消费者取消消费接口回调逻辑");
        });
    }
}

```



由于第二个消费者处理消息时间太长，我们将其关闭后，可以发现他所接受到的消息会重新入队并且让第一个消费者接收了。



#### 持久化

##### 概念

在RabbitMQ服务器宕机或者因某种情况退出后，它会忽视队列和消息，导致生产者发送的消息丢失。为确保消息不丢失，我们就需要将**队列和消息** 标记为持久化

##### 队列持久化

非持久化，当rabbitmq重启，那么队列就会删除。

```java
// 声明队列
// 持久化 需要让Queue持久化
boolean durable = true;
channel.queueDeclare(TASK_QUEUE_NAME,durable,false,false,null);
```

注意：

如果之前声明的队列不是持久化的，需要把原先队列先删除或者重新创建一个持久化的队列，不然就会出现错误

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/498c3932f734473e93ed8ac0d26ae71b.png)



网页端Features(D)，表示队列持久化

![image-20230223233646270](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230223233646270.png)



##### 消息持久化

1. 要想让消息实现持久化需要在消息生产者修改代码,MessageProperties,PERSISTENT_TEXT_PLAIN添加这个属性。
2. 将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉RabbitMQ将消息保存到磁盘，**但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。**持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。

```java
//设置生产者发送消息为持久化消息（要求保存到磁盘上）
channel.basicPublish("",TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN(持久化纯文本)
                     ,message.getBytes(StandardCharsets.UTF_8));
System.out.println("生产者发出消息："+message);
```



#### 不公平发放

轮询分放的弊端：因为不同消费者处理消息速度不同，有的快有的慢。如果此时按照轮询分放，就会导致处理快的消费者处于等待。

> 设置不公平发放

```java
// 设置不公平分发
int prefetchCount = 1;
channel.basicQos(prefetchCount)
```

### 3.3  预取值

![image-20230224082712975](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230224082712975.png)



> 该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。
>
> 通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的RAM消耗(随机存取存储器)
>
> 消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程



```java
//设置不公平分放
//int prefetchCount=1;

//预期值设置
int prefetchCount=5;
channel.basicQos(prefetchCount);
```

![image-20230224083737813](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230224083737813.png)



![image-20230224083745157](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230224083745157.png)

![image-20230224083709391](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230224083709391.png)



可以看到c2一开始堆积了四条，c1处理一条外加最多堆积两条，所以七条剩下四条。



![image-20230224084211392](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230224084211392.png)



## 4.发布确认

发送者没法确认是否发送成功,消费者处理失败也无法反馈.

没有消息确认机制,就会出现消息莫名其妙的没了,也不知道什么情况.

> 保证消息不丢失的方法
>
> 1. 设置要求队列持久化
> 2. 设置队列中信息持久化
> 3. 发布确认



### 发布确认策略

#### 开启发布确认

```java
Channel channel = connection.createChannel();
channel.confirmSelect();
```



#### 单个发布确认

> 1. 发布一个消息之后只有它被确认发布，后续的消息才能继续发布, waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。
> 2. 缺点:`发布速度慢`，如果没有确认发布消息就会阻塞后面所有的消息，不适于超过百条的消息吞吐量

```java
package RabbitMQ.ConfirmMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import org.apache.commons.lang3.time.StopWatch;

import java.io.IOException;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class ConfirmMessage {

    private static final int MESSAGE_COUNT = 1000;

    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        publishMessageIndividually();
    }

    public static void publishMessageIndividually() throws IOException, TimeoutException, InterruptedException {
        Channel channel = RabbitMqUtils.getChannel();
        String queueName = UUID.randomUUID().toString();
        channel.queueDeclare(queueName, false, false, false, null);
        //开启消息确认
        channel.confirmSelect();

        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        for (int i = 0; i < MESSAGE_COUNT; i++) {
            String message=i+"";
            channel.basicPublish("",queueName,null,message.getBytes());
            boolean flag=channel.waitForConfirms();
            if (flag) {
                System.out.println("消息发送成功");
            }
        }

        stopWatch.stop();

        System.out.println("发布1000个单独确认消息耗时："+stopWatch.getTime()+"ms");
			///发布1000个单独确认消息耗时：187ms

    }
}
```



#### 批量发布发布

优点：提高吞吐量，速度快

缺点：发生故障出现问题，无法进行排查，只能重新发布消息。

该方法是同步的，也会阻塞消息的发布。



```java
public static void publishMessageBatch() throws Exception{
    Channel channel = RabbitMqUtils.getChannel();
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName,false,false,false,null);

    // 开启发布确认
    channel.confirmSelect();
    // 开始时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();

    // 批量确认消息大小
    int batchSize = 1000;

    // 批量发送 批量确认
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = i + "";
        channel.basicPublish("",queueName,null,message.getBytes(StandardCharsets.UTF_8));

        // 判断达到100条消息的时候，批量确认一次
        if (i%batchSize == 0){
            // 确认发布
            channel.waitForConfirms();
        }
    }

    // 结束时间
    stopWatch.stop();
    System.out.println("发布"+MESSAGE_COUNT+"个批量确认消息，耗时"+ stopWatch.getTime() + "ms");
    //发布1000个批量确认消息，耗时35ms
}
```



#### 异步确认发布

![image-20230224093358563](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5339/image-20230224093358563.png)

优点：异步确认，可以对成功失败消息进行通知

缺点：复杂

```java
public static void publicMessageAsync() throws IOException, TimeoutException {
    Channel channel = RabbitMqUtils.getChannel();
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, false, false, false, null);

    // 开启发布确认
    channel.confirmSelect();
    // 开始时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();

    // 消息确认成功回调函数
    ConfirmCallback ackCallback = (deliveryTag, multiply) -> {
        System.out.println("确认的消息：" + deliveryTag);
    };

    // 消息确认失败回调函数
    /*
     * 参数1：消息的标记
     * 参数2：是否为批量确认
     * */
    ConfirmCallback nackCallback = (deliveryTag, multiply) -> {
        System.out.println("未确认的消息：" + deliveryTag);
    };

    // 添加确认的监听器
    channel.addConfirmListener(ackCallback, nackCallback);
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = "消息" + i;
        channel.basicPublish("", queueName, null, message.getBytes(StandardCharsets.UTF_8));
    }
    stopWatch.stop();
    System.out.println("发布" + MESSAGE_COUNT + "个异步消息，耗时:" + stopWatch.getTime() + "ms");
    发布1000个异步消息，耗时:32ms
}
```



> 如何处理异步未确认的消息

最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用**ConcurrentLinkedQueue**这个队列在confirm callbacks与发布线程之间进行消息的传递





```java
public static void publicMessageAsync() throws IOException, TimeoutException {
    Channel channel = RabbitMqUtils.getChannel();
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, false, false, false, null);

    // 开启发布确认
    channel.confirmSelect();
    // 开始时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();



    /*
         * 线程安全有序的一个哈希表 适用于高并发的情况下
         * 1、轻松地将序号与消息进行关联
         * 2、轻松地批量删除，只要给到序号
         * 3、支持高并发
         * */
    ConcurrentSkipListMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();


    /*
         * 参数1：消息的标记
         * 参数2：是否为批量确认
         * */

    // 消息确认成功回调函数
    ConfirmCallback ackCallback = (deliveryTag, multiply) -> {
        //批量确认 就删除当前映射
        if (multiply) {
            ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(deliveryTag);
            confirmed.clear();

        } else {
            outstandingConfirms.remove(deliveryTag);
        }

        System.out.println("确认的消息:"+deliveryTag);
    };

    // 消息确认失败回调函数

    ConfirmCallback nackCallback = (deliveryTag, multiply) -> {
        String message = outstandingConfirms.get(deliveryTag);
        System.out.println("未确认的消息：" + message+":::tags:"+deliveryTag);
    };

    // 添加确认的监听器
    channel.addConfirmListener(ackCallback, nackCallback);
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = "消息" + i;
        channel.basicPublish("", queueName, null, message.getBytes(StandardCharsets.UTF_8));
        // 下一个发布序列号作为key
        outstandingConfirms.put(channel.getNextPublishSeqNo(), message);
    }
    stopWatch.stop();
    System.out.println("发布" + MESSAGE_COUNT + "个异步消息，耗时:" + stopWatch.getTime() + "ms");
    /发布1000个异步消息，耗时:32ms
}

```

