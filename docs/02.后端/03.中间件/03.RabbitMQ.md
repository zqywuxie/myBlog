---
title: RabbitMQ
date: 2023-02-23 18:53:05
permalink: /pages/337fc2/
---
# RabbitMQ

## 1.MQ

### 1.1 介绍

> 相关概念

MQ(message queue)，从字面意思上看，本质是个队列，[FIFO](https://so.csdn.net/so/search?q=FIFO&spm=1001.2101.3001.7020)先入先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中,MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。



> 使用场景

<font color='red'>1.流量消峰</font>

订单系统最多处理1万次请求，但在高峰期，会出现超过限度的请求，此时如果全部接受，就会导致系统崩溃宕机。

`MQ`的作用就进行接受请求作为缓存，将一次性发送的请求，分批次传递给系统。

优点： 避免系统崩溃宕机

缺点：用户发送的请求可能会等很久才会收到结果

![image-20230223185311713](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223185311713.png)



<font color='red'>2.应用解耦</font>

![image-20230223185658725](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223185658725.png)

用户创建订单后，系统会进行一系列操作，如果某一个操作出了故障就会导致下单操作异常。使用`MQ`就将发生故障的操作数据存在队列当中，操作继续执行，等故障修复后，接着处理未完成的操作。

优点：操作者感知不到系统的故障，提升了系统的可用性

<font color='red'>3.异步处理</font>

![image-20230223190051622](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223190051622.png)

有些服务间是异步调用，比如A调用B。如果B需要很长时间执行，A需要知道执行结束时间，以前有两种方式。

一是A过段时间就去调用B的查询，查询B多久结束。

二是A提供一个callback（回调函数）api，当B执行完毕后就调用api通知A；

上面两种都要进行多余的操作，不够优雅。

使用`MQ`，B执行完后给`MQ`发送消息，然后再将结束信息转发给A。



### 1.2 MQ分类



1. `ActiveMQ`：

   - 优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据
   - 缺点：维护越来越少，高吞吐量场景较少使用

2. `Kafka`：大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件,以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输存储的过程中发挥着举足轻重的作用。目前已经被LinkedIn，Uber,Twitter,Netflix等大公司所采纳。

   - 优点：

     性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。时效性ms级可用性非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用Pull方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web管理界面Kafka-Manager;在日志领域比较成熟，被多家公司和多个开源项目使用;功能支持:功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用

   - 缺点：

     Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试;支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢;

3. `RocketMQ`：出自阿里巴巴的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理binglog分发等场
   景。

   - 优点：

     单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到0丢失,MQ功能较为完善，还是分布式的，扩展性好,支持10亿级别的消息堆积，不会因为堆积导致性能下降,源码是java我们可以自己阅读源码，定制自己公司的MQ

   - 缺点：

     支持的客户端语言不多，目前是java及c++，其中c++不成熟;社区活跃度一般,没有在MQ核心中去实现JMS等接口,有些系统要迁移需要修改大量代码

4. `RabbitMQ`：2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。

   - 优点：

     由于erlang语言的高并发特性，性能较好;吞吐量到万级，MQ功能比较完备,健壮、稳定、易用、跨平台、支持多种语言如: Python、Ruby、.NET、 Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX文档齐全;开源提供的管理界面非常棒，用起来很好用,社区活跃度高;
     更新频率相当高

   - 缺点：

     商业版需要收费,学习成本较高



### 1.3 选择

| MQ       | 介绍                                                         |
| -------- | ------------------------------------------------------------ |
| MQ       | 介绍                                                         |
| Kafka    | Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生`大量数据`的互联网服务的数据收集业务。`大型公司`建议可以选用，如果有`日志采集`功能,肯定是首选kafka了。 |
| RocketMQ | 天生为`金融互联网`领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。 |
| RabbitMQ | 结合erlang语言本身的并发优势，`性能好时效性微秒级`，`社区活跃度也比较高`，管理界面用起来十分方便，如果你的`数据量没有那么大`，中小型公司优先选择功能比较完备的RabbitMO |



## 2.RabbitMQ

### 2.1 介绍

> 概念

RabbitMQ是一个消息中间件:它接受并转发消息。它不处理信息，只负责**接受，存储，转发**。

> 四大核心概念

![image-20230223191225964](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223191225964.png)



| 概念   | 介绍                                                         |
| ------ | ------------------------------------------------------------ |
| 生产者 | 产生数据发送消息的程序是生产者                               |
| 交换机 | 对信息接受并处理。交换机需要知道对信息如何处理，推送单个队列或多个队列或丢弃，由交换机类型决定。 |
| 队列   | 存储信息的数据结构，仅受主机内容和磁盘限制，本质是一个大的消息缓冲区。多个生产者可以将消息发送一个队列中，多个消费者可以**尝试**从一个队列中获取信息，但**接收到的只有一个消费者。** |
| 消费者 | 消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件**很多时候并不在同一机器上**。同一个应用程序既可以是生产者又是可以是消费者。 |



### 2.2 核心部分

![image-20230223191844366](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223191844366.png)



| 部分         | 功能                                                         |
| ------------ | ------------------------------------------------------------ |
| Borker       | 接受和分发消息的应用，RabbitMQ Server就是Message Broker      |
| Connection   | publisher / consumer和broker之间的TCP连接                    |
| Channel      | 如果每一次访问 RabbitMQ 都建立一个Connection，在消息量大的时候建立TCPConnection的开销将是巨大的，效率也较低。Channel是在connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread 创建单独的channel进行通讯，AMQP method包含了channel id 帮助客户端和message broker识别 channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。每次发消息只会占用**一个**channel，发多次消息 |
| Virtual host | 每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的connection、exchange、queue、binding等，拥有自己的权限。vhost之于RabbitMQ就像虚拟机于物理机一样，他们通过在各个实例间提供逻辑上分离，允许为不同的应用程序安全保密的运行数据。 |
| Exchange     | message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有: direct (point-to-point), topic (publish-subscribe) and fanout (multicast) |
| Queue        | 消息最终被送到这里等到consumer取走                           |
| Binding      | exchange和queue之间的虚拟连接，binding中可以包含routing key，**Binding消息被保存到exchange中的查询表中**，用于message的分发依据 |

### 2.3 安装

笔者在ubuntu下学习

[ubuntu下](https://zhuanlan.zhihu.com/p/545276968)

```sh

# 查看状态
systemctl status rabbitmq-server

# 启动
systemctl start rabbitmq-server
# 停止
systemctl stop rabbitmq-server

#安装可视化管理 插件
rabbitmq-plugins enable rabbitmq_management
http://localhost:15672/

初始化账号和密码 guest

# 创建账号
rabbitmqctl add_user admin 123

# 设置用户角色
rabitmqctl set_user_tags admin adminstrator

# 设置用户权限
set_permissions[-p ,<vhostpath>]<user><config><write><read>
rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"

# 查看用户列表
rabbitmqctl list_users
```

![image-20230223194123458](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223194123458.png)



![image-20230223194512644](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223194512644.png)



### 2.4 Java环境

maven工程下

> 准备

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.8.0</version>
</dependency>

<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.6</version>
</dependency>
```

#### 2.4.1 案例一

![image-20230223195559882](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223195559882.png)

##### 生产者代码

```java
package RabbitMQ.Day1;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:生产者
 * @ClassName:Producer
 */

public class Producer {

    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        //        创建连接工厂
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 设置连接RabbitMQ的IP
        connectionFactory.setHost("localhost");
        // 用户名
        connectionFactory.setUsername("guest");
        //密码
        connectionFactory.setPassword("guest");
        //端口
        connectionFactory.setPort(5672);
        //创建连接
        Connection connection = connectionFactory.newConnection();
        //创建通道
        Channel channel = connection.createChannel();

        /**
         * 生成队列
         * 参数1 队列名
         * 参数2：队列里面的消息是否持久化，默认情况下，消息存储在内存中
         * 参数3：该队列是否只供一个消费者进行消费，是否进行消费共享，true可以多个消费者消费，
         *     false只能一个消费者消费
         * 参数4：是否自动删除：最后一个消费者断开连接之后，该队列是否自动删除，true则自动删除，
         *    false不自动删除
         * 参数5：其他参数
         */
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        //发送消息
        String message = "hello,world";

        /*
         * 发送一个消息
         * 参数1：发送到哪个交换机
         * 参数2：路由的key值是那个，本次是队列的名称
         * 参数3：其他参数信息
         * 参数4：发送消息的消息体
         * */
        channel.basicPublish("", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));

        System.out.println("消息发送完毕！");
    }

}

```



##### 消费者代码

```java
package RabbitMQ.Day1;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:消费者
 * @ClassName:Consumer
 */

public class Consumer {

    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        ConnectionFactory connectionFactory = new ConnectionFactory();
        // 设置连接RabbitMQ的IP
        connectionFactory.setHost("localhost");
        // 用户名
        connectionFactory.setUsername("guest");
        //密码
        connectionFactory.setPassword("guest");
        //端口
        connectionFactory.setPort(5672);
        //创建连接
        Connection connection = connectionFactory.newConnection();
        //创建通道
        Channel channel = connection.createChannel();

        // 声明 接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            System.out.println(new String(message.getBody()));
        };

        //声明 取消消息
        CancelCallback cancelCallback = consumer -> {
            System.out.println("消息被中断");
        };



        /*
         * 消费者接收消息
         * 参数1：表示消费哪个队列
         * 参数2：消费成功之后，是否需要自动应答，true表示自动应答，false表示手动应答
         * 参数3：消费者成功消费的回调
         * 参数4：消费者取消消费的回调
         */
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}

```



## 3. workqueue（工作队列）

主要思想避免立即执行任务，而当前进程必须等待完成。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。

（采取轮询策略，一个线程得到任务，就访问下一个工作线程）

![image-20230223202415004](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223202415004.png)



### 3.1 轮训分发消息

##### 工作线程代码

```java
package RabbitMQ.WorkQueue;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Worker01
 */

public class Worker01 {
    // 队列名称
    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        // 接受消息参数
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            System.out.println("接受到的消息：" + new String(message.getBody()));
        };

        // 取消消费参数
        CancelCallback cancelCallback = consumerTag -> {
            System.out.println(consumerTag + "消费者取消消费借口回调逻辑");
        };

        System.out.println("C1等待接受消息.....");

        // 消息的接受
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}

```



在IDEA里面进行设置，程序开启多进程

![image-20230223203145922](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223203145922.png)





##### 生产者代码

```java
package RabbitMQ.WorkQueue;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class Producer {
    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            System.out.println("发送消息完成:" + message);
        }
    }
}

```

##### 结果

![image-20230223204628022](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223204628022.png)



![image-20230223204654090](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223204654090.png)



![image-20230223204700890](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223204700890.png)



**轮询效果**



### 3.2 消息应答

#### 概念

为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制，消息应答就是:消费者在接收到消息并且**处理该消息之后**，告诉RabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。



#### 自动应答

**消息发送后立即被认为已经传送成功**，这种模式需要在高吞吐量和数据传输安全性方面做权衡。如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了。并且没有对传递的消息数量进行限制，可能导致消费者来不及接受，导致信息堆积，使得内存耗尽，最终消费者线程被操作系统杀死。

**所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。**



#### 手动应答方法

1. Channel.basicAck(用于肯定确认)

   RabbitMQ已知道该消息并且成功处理，可以将其丢弃

2. Channel.basicNack(用于否定确认)

3. Channel.basicReject(用于否定确认)，与Channel.basicNack相比少了一个参数，不处理该消息了，直接拒绝，可以将其丢弃了。



> Multiple

手动应答的好处是`可以批量应答并且减少网络拥堵`

![image-20230223205841705](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223205841705.png)



multiple的true和false是不同的意思：

1. true表示批量应答channel上未应答的消息，比如channel上有传送tag的消息5,6,7,8,，当前tag是8，那么此时5-8的这些还未应答的消息就会被确认收到消息应答
2. false同上面相比**只会应答tag=8**的消息，5,6,7这三个消息依然不会被确认收到消息应答



#### 消息重新入队

> 如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将**了解到消息未完全处理，并将对其重新排队**。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。



![image-20230223210216401](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223210216401.png)



##### 生产者代码

```java
package RabbitMQ.ReplyMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class Producer {
    public static final String TASK_QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        // 声明队列
        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            channel.basicPublish("", TASK_QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println("生产者发出消息：" + message);
        }

    }
}

```



##### 消费者代码

```java
package RabbitMQ.ReplyMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static RabbitMQ.ReplyMessage.Producer.TASK_QUEUE_NAME;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Consumer
 */

public class Consumer {

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();
        System.out.println("C1等待接受消息处理时间较短");

        DeliverCallback deliverCallback = (consumerTag, message) -> {
            // 沉睡一秒
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {


            }
            System.out.println("接受到的消息是:"+new String(message.getBody()));

            //进行手动应答
            /*
             * 参数1：消息的标记  tag
             * 参数2：是否批量应答，false：不批量应答 true：批量
             * */
            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
        };


        // 采用手动应答
        boolean autoAck = false;
        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag) -> {
            System.out.println(consumerTag+"消费者取消消费接口回调逻辑");
        });
    }
}

```



```java
package RabbitMQ.ReplyMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static RabbitMQ.ReplyMessage.Producer.TASK_QUEUE_NAME;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:(TODO)描述该类
 * @ClassName:Consumer1
 */

public class Consumer1 {
    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();
        System.out.println("C2等待接受消息处理时间较短");

        DeliverCallback deliverCallback = (consumerTag, message) -> {
            // 沉睡30秒
            try {
                TimeUnit.SECONDS.sleep(30);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("接受到的消息是:"+new String(message.getBody()));

            //进行手动应答
            /*
             * 参数1：消息的标记  tag
             * 参数2：是否批量应答，false：不批量应答 true：批量
             * */
            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
        };


        // 采用手动应答
        boolean autoAck = false;
        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag) -> {
            System.out.println(consumerTag+"消费者取消消费接口回调逻辑");
        });
    }
}

```



由于第二个消费者处理消息时间太长，我们将其关闭后，可以发现他所接受到的消息会重新入队并且让第一个消费者接收了。



#### 持久化

##### 概念

在RabbitMQ服务器宕机或者因某种情况退出后，它会忽视队列和消息，导致生产者发送的消息丢失。为确保消息不丢失，我们就需要将**队列和消息** 标记为持久化

##### 队列持久化

非持久化，当rabbitmq重启，那么队列就会删除。

```java
// 声明队列
// 持久化 需要让Queue持久化
boolean durable = true;
channel.queueDeclare(TASK_QUEUE_NAME,durable,false,false,null);
```

注意：

如果之前声明的队列不是持久化的，需要把原先队列先删除或者重新创建一个持久化的队列，不然就会出现错误

![](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/498c3932f734473e93ed8ac0d26ae71b.png)



网页端Features(D)，表示队列持久化

![image-20230223233646270](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230223233646270.png)



##### 消息持久化

1. 要想让消息实现持久化需要在消息生产者修改代码,MessageProperties,PERSISTENT_TEXT_PLAIN添加这个属性。
2. 将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉RabbitMQ将消息保存到磁盘，**但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。**持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。

```java
//设置生产者发送消息为持久化消息（要求保存到磁盘上）
channel.basicPublish("",TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN(持久化纯文本)
                     ,message.getBytes(StandardCharsets.UTF_8));
System.out.println("生产者发出消息："+message);
```



#### 不公平发放

轮询分放的弊端：因为不同消费者处理消息速度不同，有的快有的慢。如果此时按照轮询分放，就会导致处理快的消费者处于等待。

> 设置不公平发放

```java
// 设置不公平分发
int prefetchCount = 1;
channel.basicQos(prefetchCount)
```

### 3.3  预取值

![image-20230224082712975](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224082712975.png)



> 该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。
>
> 通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的RAM消耗(随机存取存储器)
>
> 消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程



```java
//设置不公平分放
//int prefetchCount=1;

//预期值设置
int prefetchCount=5;
channel.basicQos(prefetchCount);
```

![image-20230224083737813](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224083737813.png)



![image-20230224083745157](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224083745157.png)

![image-20230224083709391](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224083709391.png)



可以看到c2一开始堆积了四条，c1处理一条外加最多堆积两条，所以七条剩下四条。



![image-20230224084211392](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224084211392.png)



## 4.发布确认

发送者没法确认是否发送成功,消费者处理失败也无法反馈.

没有消息确认机制,就会出现消息莫名其妙的没了,也不知道什么情况.

> 保证消息不丢失的方法
>
> 1. 设置要求队列持久化
> 2. 设置队列中信息持久化
> 3. 发布确认



### 4.1发布确认策略

#### 开启发布确认

```java
Channel channel = connection.createChannel();
channel.confirmSelect();
```



#### 单个发布确认

> 1. 发布一个消息之后只有它被确认发布，后续的消息才能继续发布, waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。
> 2. 缺点:`发布速度慢`，如果没有确认发布消息就会阻塞后面所有的消息，不适于超过百条的消息吞吐量

```java
package RabbitMQ.ConfirmMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import org.apache.commons.lang3.time.StopWatch;

import java.io.IOException;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class ConfirmMessage {

    private static final int MESSAGE_COUNT = 1000;

    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        publishMessageIndividually();
    }

    public static void publishMessageIndividually() throws IOException, TimeoutException, InterruptedException {
        Channel channel = RabbitMqUtils.getChannel();
        String queueName = UUID.randomUUID().toString();
        channel.queueDeclare(queueName, false, false, false, null);
        //开启消息确认
        channel.confirmSelect();

        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        for (int i = 0; i < MESSAGE_COUNT; i++) {
            String message=i+"";
            channel.basicPublish("",queueName,null,message.getBytes());
            boolean flag=channel.waitForConfirms();
            if (flag) {
                System.out.println("消息发送成功");
            }
        }

        stopWatch.stop();

        System.out.println("发布1000个单独确认消息耗时："+stopWatch.getTime()+"ms");
			///发布1000个单独确认消息耗时：187ms

    }
}
```



#### 批量发布发布

优点：提高吞吐量，速度快

缺点：发生故障出现问题，无法进行排查，只能重新发布消息。

该方法是同步的，也会阻塞消息的发布。



```java
public static void publishMessageBatch() throws Exception{
    Channel channel = RabbitMqUtils.getChannel();
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName,false,false,false,null);

    // 开启发布确认
    channel.confirmSelect();
    // 开始时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();

    // 批量确认消息大小
    int batchSize = 1000;

    // 批量发送 批量确认
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = i + "";
        channel.basicPublish("",queueName,null,message.getBytes(StandardCharsets.UTF_8));

        // 判断达到100条消息的时候，批量确认一次
        if (i%batchSize == 0){
            // 确认发布
            channel.waitForConfirms();
        }
    }

    // 结束时间
    stopWatch.stop();
    System.out.println("发布"+MESSAGE_COUNT+"个批量确认消息，耗时"+ stopWatch.getTime() + "ms");
    //发布1000个批量确认消息，耗时35ms
}
```



#### 异步确认发布

![image-20230224093358563](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224093358563.png)

优点：异步确认，可以对成功失败消息进行通知

缺点：复杂

```java
public static void publicMessageAsync() throws IOException, TimeoutException {
    Channel channel = RabbitMqUtils.getChannel();
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, false, false, false, null);

    // 开启发布确认
    channel.confirmSelect();
    // 开始时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();

    // 消息确认成功回调函数
    ConfirmCallback ackCallback = (deliveryTag, multiply) -> {
        System.out.println("确认的消息：" + deliveryTag);
    };

    // 消息确认失败回调函数
    /*
     * 参数1：消息的标记
     * 参数2：是否为批量确认
     * */
    ConfirmCallback nackCallback = (deliveryTag, multiply) -> {
        System.out.println("未确认的消息：" + deliveryTag);
    };

    // 添加确认的监听器
    channel.addConfirmListener(ackCallback, nackCallback);
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = "消息" + i;
        channel.basicPublish("", queueName, null, message.getBytes(StandardCharsets.UTF_8));
    }
    stopWatch.stop();
    System.out.println("发布" + MESSAGE_COUNT + "个异步消息，耗时:" + stopWatch.getTime() + "ms");
    发布1000个异步消息，耗时:32ms
}
```



> 如何处理异步未确认的消息

最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用**ConcurrentLinkedQueue**这个队列在confirm callbacks与发布线程之间进行消息的传递





```java
public static void publicMessageAsync() throws IOException, TimeoutException {
    Channel channel = RabbitMqUtils.getChannel();
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, false, false, false, null);

    // 开启发布确认
    channel.confirmSelect();
    // 开始时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();



    /*
         * 线程安全有序的一个哈希表 适用于高并发的情况下
         * 1、轻松地将序号与消息进行关联
         * 2、轻松地批量删除，只要给到序号
         * 3、支持高并发
         * */
    ConcurrentSkipListMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();


    /*
         * 参数1：消息的标记
         * 参数2：是否为批量确认
         * */

    // 消息确认成功回调函数
    ConfirmCallback ackCallback = (deliveryTag, multiply) -> {
        //批量确认 就删除当前映射
        if (multiply) {
            ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(deliveryTag);
            confirmed.clear();

        } else {
            outstandingConfirms.remove(deliveryTag);
        }

        System.out.println("确认的消息:"+deliveryTag);
    };

    // 消息确认失败回调函数

    ConfirmCallback nackCallback = (deliveryTag, multiply) -> {
        String message = outstandingConfirms.get(deliveryTag);
        System.out.println("未确认的消息：" + message+":::tags:"+deliveryTag);
    };

    // 添加确认的监听器
    channel.addConfirmListener(ackCallback, nackCallback);
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        String message = "消息" + i;
        channel.basicPublish("", queueName, null, message.getBytes(StandardCharsets.UTF_8));
        // 下一个发布序列号作为key
        outstandingConfirms.put(channel.getNextPublishSeqNo(), message);
    }
    stopWatch.stop();
    System.out.println("发布" + MESSAGE_COUNT + "个异步消息，耗时:" + stopWatch.getTime() + "ms");
    /发布1000个异步消息，耗时:32ms
}

```

性能比较

1.单个发布

> 发布1000个单独确认消息耗时：187ms

2.批量发布

> 发布1000个批量确认消息，耗时35ms

3.异步发布(推荐)

> 发布1000个异步消息，耗时:32ms





## 5.交换机

### 5.1概念

![image-20230224155514474](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224155514474.png)



> 介绍

1. RabbitMQ消息传递模型的核心思想是：`生产者生产的消息从不会直接发送到队列`。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。

2. 生产者**只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。

3. 总共有以下几个类型：

   直接（direct）、主题（topic）、标题（headers）、扇出（fanout）

4. 无名交换机：

   在本教程的前面部分我们对exchange一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串("")进行标识。

   第一个参数是交换机的名称。空字符串表示默认或无名称交换机:消息能路由发送到队列中其实是由routingKey(bindingkey)绑定key指定的，如果它存在的话

   

   ```java
   channel.basiPublish("","hello",null,message.getBytes())；
   ```

### 5.2 临时队列

1. 每当我们连接到Rabbit时，我们都需要一个全新的空队列，为此**我们可以创建一个具有随机名称的队列**，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦**我们断开了消费者的连接，队列将被自动删除**。

2. 创建临时队列的方式如下：

   ```java
   String queueName = channel.queueDeclare().getQueue();
   ```



![image-20230224160159542](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224160159542.png)



### 5.3 绑定（bindings）

> 介绍

交换机和队列之间的桥梁

![image-20230224160521476](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224160521476.png)



### 5.4 扇出（Fanout）

#### 概念

将接收到的所有消息广播到它知道的所有队列中。系统中有默认的

![image-20230224160732448](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224160732448.png)



#### 消费者代码

```java
package RabbitMQ.Exchange;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:ReceiveLog1
 */

public class ReceiveLog1 {

    private static final String EXCHANGE_NAME = "logs";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        //设置交换机
        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");

        // 声明临时队列
        String queue = channel.queueDeclare().getQueue();

        channel.queueBind(queue, EXCHANGE_NAME, "");
        System.out.println("接收方1等待消息：");

        DeliverCallback deliverCallback=(deliverTag,message)->{
            System.out.println("接收到消息："+new String(message.getBody(), StandardCharsets.UTF_8));
        };

        channel.basicConsume(queue,true,deliverCallback, (CancelCallback) null);

    }
}

```

```java
channel.queueBind(queue, EXCHANGE_NAME, "");
```

**因为两个channel的routingkey设置为空，默认的，所以才可以都收到同样的消息。**



#### 生产者代码

```java
package RabbitMQ.Exchange;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:EmitLog
 */

public class EmitLog {
    private static final String EXCHANGE_NAME = "logs";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes());
            System.out.println("生产者发送消息：" + message);

        }
    }
}

```





![image-20230224162140324](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224162140324.png)





![image-20230224162151694](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224162151694.png)



![image-20230224162207084](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224162207084.png)



### 5.5 直接（direct）

#### 概念

> 介绍

消息只去它绑定的routingkey队列中去。如果routingkey一致，那么就是变种的`Fanout`类型。



![image-20230224163229995](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224163229995.png)



> 实战

![image-20230224163552393](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224163552393.png)



#### 生产者代码

```java
package RabbitMQ.DirectType;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:EmitLog
 */

public class EmitLog {
    private static final String EXCHANGE_NAME = "direct_logs";
    private static final String ROUTINGKEY="warning";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        //可用枚举类 选择交换机类型
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME, ROUTINGKEY, null, message.getBytes());
            System.out.println("生产者向 "+ROUTINGKEY+"发送消息：" + message);

        }
    }
}

```



#### 消费者代码

```java
package RabbitMQ.DirectType;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:ReceiveLogs
 */

public class ReceiveLogs1 {

    private static final String EXCHANGE_NAME = "direct_logs";
    private static final String QUEUE_NAME = "disk";


    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        //设置交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
		
        //声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "error");
        System.out.println("接收方2(error)等待消息：");

        DeliverCallback deliverCallback = (deliverTag, message) -> {
            System.out.println("接收到消息：" + new String(message.getBody(), StandardCharsets.UTF_8));
        };

        channel.basicConsume(QUEUE_NAME, true, deliverCallback, (CancelCallback) null);

    }
}

```



**消费二号代码同上，更改队列名和routingkey**



### 5.6 主题（topic）

#### 概念

> 介绍

1. 发送到类型是topic交换机的消息的routing_key不能随意写，必须满足一定的要求，它`必须是一个单词列表，以点号分隔开`。这些单词可以是任意单词，比如说: “stock.usd.nyse” ， “nyse.vmw”，"quick.orange.rabbit"这种类型的。当然这个单词列表最多不能超过255个字节。
2. 在这个规则列表中，其中有两个替换符：
   - `*` 可以代替一个单词
   - `#` 可以代替零个或多个单词
3.   任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上。使用的是一种正则匹配规则。生产者会发送一个带路由键的消息。Exchange会将消息转发到所有关注主题能与**RouteKey模糊匹配的队列**。

> 案例

![image-20230224165303578](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224165303578.png)

数据接收情况如下：

1. quick.**orange**.rabbit：被队列Q1Q2接收到
2. quick.**orange**.fox：被队列Q1接收到
3. **lazy**.brown.fox：被队列Q2接收到
4. **lazy**.pink.rabbit：虽然满足队列Q2的两个绑定但是只会被接收一次
5. quick.orange.male.rabbit：四个单词不匹配任何绑定会被丢弃



> 结论

1. 当一个队列绑定键是`#`,那么这个队列将接收所有数据，就有点像fanout了
2. 如果队列绑定键当中没有`#和*`出现，那么该队列绑定类型就是direct了



#### 生产者代码

```java
package RabbitMQ.Topic;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:EmitLogTopic
 */

public class EmitLogTopic {
    private static final String EXCHANGE_NAME = "topic_logs";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        HashMap<String, String> map = new HashMap<>();
        map.put("quick.orange.rabbit", "被队列Q1Q2接收到");
        map.put("quick.orange.fox", "被队列Q1接收到");
        map.put("lazy.brown.fox", "被队列Q2接收到 ");
        map.put("lazy.pink.rabbit", "虽然满足队列Q2的两个绑定但是只会被接收一次");
        map.put("quick.orange.male.rabbit", "四个单词不匹配任何绑定会被丢弃");
        for (String routingKey : map.keySet()) {
            System.out.println(routingKey);
            String message = map.get(routingKey);
            channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes());
            System.out.println("生产者发送消息：" + message);
        }
    }
}

```



#### 消费者代码

```java
package RabbitMQ.Topic;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:ReceiveLogsToic
 */

public class ReceiveLogsTopic {

    private static final String EXCHANGE_NAME = "topic_logs";
    private static final String QUEUE_NAME = "Q1";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定部分的routingkey改变
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "*.orange.*");
        System.out.println("Q1 接受消息。。。");

        DeliverCallback deliver = (consumeTag, message) -> {
            System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
        };

        channel.basicConsume(QUEUE_NAME, true, deliver, (CancelCallback) null);
    }
}

```

消费者二号同上，队列名和绑定routingkey进行修改即可。



![image-20230224183931316](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224183931316.png)



![image-20230224183942834](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224183942834.png)



![image-20230224183953918](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224183953918.png)





## 6.死信队列

### 概念

1. 无法被消费的消息，`某些时候由于特定的原因导致queue中的某些消息无法被消费`，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。然后再由其他特殊消费者从死信队列中获取信息进行处理。
2. 应用场景：为了**保证订单业务的消息数据不丢失**，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中.还有比如说:用户在商城下单成功并点击去支付后在**指定时间未支付时自动失效**

 

> 形成原因

1. 消息TTL过期
2. 队列达到最大长度（队列满了，无法再添加数据到mq中）
3. 消息被拒绝（basic.reject或basic.nack）并且requeue=false（不放回队列中）



> 代码架构图

![image-20230224225547994](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224225547994.png)



### 具体案例

#### 1.消息TTL过期

##### 生产者代码

```java
package RabbitMQ.DeadMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:Producer
 */

public class Producer {

    private static final String NORMAL_EXCHANGE = "normal_exchange";
    private static final String ROUTINGKEY = "zhangsan";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        // 设置消息过期时间10s
        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();

        for (int i = 0; i < 10; i++) {
            String message="info"+i;
            channel.basicPublish(NORMAL_EXCHANGE,ROUTINGKEY,properties,message.getBytes());
        }
    }

}

```

##### 消费者代码（正常队列

```java
package RabbitMQ.DeadMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description:(TODO)描述该类
 * @ClassName:Consumer0
 */

public class Consumer0 {

    private static final String NORMAL_EXCHANGE = "normal_exchange";

    private static final String NORMAL_QUEUE = "normal_queue";

    private static final String DEAD_EXCHANGE = "dead_exchange";
    private static final String DEAD_QUEUE = "dead_queue";

    private static final String Dead_ROUTINGKEY = "lisi";
    private static final String NORMAL_ROUTINGKEY = "zhangsan";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);

        HashMap<String, Object> arguments = new HashMap<>();

        //消息过期时间1s, 该队列消息未处理就过期了,就会转移到死信队列中
        arguments.put("x-message-ttl", 1000);

        //死信交换机
        arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);

        //死信routingkey
        arguments.put("x-dead-letter-routing-key", Dead_ROUTINGKEY);


        channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);

        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTINGKEY);
        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, Dead_ROUTINGKEY);

        DeliverCallback deliver = (consumeTag, message) -> {
            System.out.println("consumer0 收到的消息为：" + new String(message.getBody(), StandardCharsets.UTF_8));
        };

        channel.basicConsume(NORMAL_QUEUE, true, deliver, (consumerTag, sig) -> {
        });

    }
}

```



##### 消费者代码(死信处理)

```java
package RabbitMQ.DeadMessage;

import RabbitMQ.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/24
 * @Description: 消费2 用于处理死信
 * @ClassName:Consumer1
 */

public class Consumer1 {

    private static final String DEAD_QUEUE = "dead_queue";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMqUtils.getChannel();

        System.out.println("consumer1 等待接收消息。。。");

        DeliverCallback deliver = (consumeTag, message) -> {
            System.out.println("consumer1 接收到的消息:" + new String(message.getBody(), StandardCharsets.UTF_8));
        };
        channel.basicConsume(DEAD_QUEUE, true, deliver, consumerTag -> {
        });
    }
}

```

![image-20230224232627857](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224232627857.png)

![image-20230224232616544](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224232616544.png)



结果可见，正常队列没有接收到消息，打开第二个消费者，就接收到全部消息了



#### 2. 队列达到最大长度

不对消息进行过期时间设置。

 

##### 生产者代码

```java
//        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();

        for (int i = 0; i < 10; i++) {
            String message="info"+i;
            channel.basicPublish(NORMAL_EXCHANGE,ROUTINGKEY,null,message.getBytes());}
```



##### 消费者代码（正常队列）

```java
        //消息过期时间
		//arguments.put("x-message-ttl", 1000);
        //设置接收信息最大长度
		arguments.put("x-max-length",6);

```



消费者2代码不做改变

![image-20230224233636607](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224233636607.png)



![image-20230224233629728](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224233629728.png)



#### 3. 消息被拒

生产者代码不变

##### 消费者代码(正常队列)

```java
DeliverCallback deliver = (consumeTag, message) -> {
    String ms=new String(message.getBody(),StandardCharsets.UTF_8);
    if ("info5".equals(ms)){
        System.out.println("consumer0 拒绝消息:"+ms);
    
 

//拒绝应答操作
        channel.basicReject(message.getEnvelope().getDeliveryTag(),false);
    }
    System.out.println("consumer0 收到的消息为：" + new String(message.getBody(), StandardCharsets.UTF_8));
};


//开启手动应答
channel.basicConsume(NORMAL_QUEUE, false, deliver, (consumerTag, sig) -> {});
```



消费者2代码不做改变



![image-20230224234521721](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224234521721.png)



![image-20230224234529039](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230224234529039.png)





## 7.延迟队列

### 概念

> 介绍

延时队列，队列**内部是有序**的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放**需要在指定时间被处理的元素**的队列。（死信队列中消息过期的一种变种）



> 使用场景

1. 订单在十分钟之内未支付则自动取消
2. 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。
3. 用户注册成功后，如果三天内没有登陆则进行短信提醒。
4. 用户发起退款，如果三天内没有得到处理则通知相关运营人员。
5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议

这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务。看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗?如果数据量比较少，确实可以这样做，比如:对于“如果账单一周内未支付则进行自动结算”这样的需求,如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。

但对于数据量比较大，并且时效性较强的场景，如:“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。



### 准备工作

#### 1.创建springboot工程

https://start.aliyun.com/

添加相关依赖

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.73</version>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>

<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>

<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>

<dependency>
    <groupId>org.springframework.amqp</groupId>
    <artifactId>spring-rabbit-test</artifactId>
    <scope>test</scope>
</dependency>
```



#### 2.配置类

```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket webApiConfig(){
        return new Docket(DocumentationType.SWAGGER_2)
            .groupName("webApi")
            .apiInfo(webApiInfo())
            .select()
            .build();
    }

    private ApiInfo webApiInfo(){
        return new ApiInfoBuilder()
            .title("rabbitmq接口文档")
            .description("本文档描述了rabbitmq微服务接口定义")
            .version("1.0")
            .contact(new Contact("enjoy6288","http://atguigu.com","123456@qq.com"))
            .build();
    }
}
```





### 具体案例

![image-20230225090642861](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225090642861.png)

#### 代码实现(死信队列)

项目结构

![image-20230225095425654](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225095425654.png)



> TtlQueueConfig 进行队列，交换机的声明和绑定

```java
package com.example.javacode.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Objects;

/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:TtlQueueCofig
 */


@Configuration
public class TtlQueueConfig {

    public static final String X_EXCHANGE = "X";
    public static final String Y_DEAD_EXHANGE = "Y";
    public static final String QA_QUEUE = "QA";
    public static final String QB_QUEUE = "QB";
    public static final String QD_DEAD_QUEUE = "QD";

    @Bean
    public DirectExchange xExchange() {
        return new DirectExchange(X_EXCHANGE);
    }

    @Bean
    public DirectExchange yExchange() {
        return new DirectExchange(Y_DEAD_EXHANGE);
    }

    @Bean
    public Queue aQueue() {
        HashMap<String, Object> agruments = new HashMap<>();
        agruments.put("x-dead-letter-exchange", Y_DEAD_EXHANGE);
        agruments.put("x-dead-letter-routing-key", "YD");
        agruments.put("x-message-ttl", 10000);
        return QueueBuilder.durable(QA_QUEUE).withArguments(agruments).build();
    }

    @Bean
    public Queue bQueue() {
        HashMap<String, Object> agruments = new HashMap<>();
        agruments.put("x-dead-letter-exchange", Y_DEAD_EXHANGE);
        agruments.put("x-dead-letter-routing-key", "YD");
        agruments.put("x-message-ttl", 40000);
        return QueueBuilder.durable(QB_QUEUE).withArguments(agruments).build();
    }

    @Bean
    public Queue dQueue() {
        return QueueBuilder.durable(QD_DEAD_QUEUE).build();
    }
    @Bean
    public Binding queueBBindingX(@Qualifier("xExchange") DirectExchange xExchange,@Qualifier("bQueue")Queue bQueue){
        return BindingBuilder.bind(bQueue).to(xExchange).with("XB");
    }
    @Bean
    public Binding queueABindingX(@Qualifier("xExchange") DirectExchange xExchange,@Qualifier("aQueue")Queue aQueue){
        return BindingBuilder.bind(aQueue).to(xExchange).with("XA");
    }

    @Bean
    public Binding queueDBindingY(@Qualifier("yExchange") DirectExchange yExchange,@Qualifier("dQueue")Queue dQueue){
        return BindingBuilder.bind(dQueue).to(yExchange).with("YD");
    }

}

```



> DeadLetterQueueConsumer  死信队列消费者

注意:Channel包，自动导入会引错，导致项目报错

```java
package com.example.javacode.consumer;

import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:DeadLetterQueueConsumer
 */

@Slf4j
@Component
public class DeadLetterQueueConsumer {

    //消息监听QD队列
    @RabbitListener(queues = "QD")
    public void receiveD(Message message, Channel channel) {
        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
        log.info("当前时间:{},收到死信队列消息:{}", new Date().toString(), msg);
    }
}

```



> SendMsgController 发送消息

```java
package com.example.javacode.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:SendMsgController
 */

@Slf4j
@RestController
@RequestMapping("/ttl")
public class SendMsgController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping("/sendMsg/{message}")
    public void sendMsg(@PathVariable String message){
        log.info("当前消息:{},发送一条消息给两个队列:{}",new Date().toString(),message);

        rabbitTemplate.convertAndSend("X","XA","消息来自TTL为10s的队列:"+message);
        rabbitTemplate.convertAndSend("X","XB","消息来自TTL为40s的队列:"+message);
    }
}

```



![image-20230225095315345](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225095315345.png)



### 优化(自定义延期时间)

需求：目前延迟队列只有两个10s和40s，如果需要增加延迟时间，就意味着需要再新增队列。创建一个根据生产者需求进行指定队列延迟时间。



新增一个QC队列，不设置TTL过期时间，由生产者指定。

```java
@Bean
public Queue cQueue() {
    HashMap<String, Object> agruments = new HashMap<>();
    agruments.put("x-dead-letter-exchange", Y_DEAD_EXHANGE);
    agruments.put("x-dead-letter-routing-key", "YD");
    // agruments.put("x-message-ttl", 40000);
    return QueueBuilder.durable(QC_QUEUE).withArguments(agruments).build();
}
```



```java
http://localhost:8080/ttl/sendExpirationMsg/你好/3000
@GetMapping("/sendExpirationMsg/{message}/{ttlTime}")
public void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {
    log.info("当前时间：{}，发送一条时长{}ms消息给队列QC：{}", new Date(), ttlTime, message);
    rabbitTemplate.convertAndSend("X", "XC", message, msg -> {

        //设置消息的延迟时间
        msg.getMessageProperties().setExpiration(ttlTime);
        return msg;
    });
}
```

![image-20230225101848044](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225101848044.png)



#### 问题 基于死信队列

![image-20230225102431127](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225102431127.png)

队列中信息是按顺序进行，**只会检查第一个消息是否过期**，如果第二条延时时间比第一条短，需要等待第一条被处理后才能接着处理。





### 插件实现延迟队列

#### 安装

https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases

```sh
下载`rabbitmq_delayed_message_exchange-3.x.x.ez`

将其移动到 /usr/lib/rabbitmq/lib/rabbitmq_server-3.9.13/plugins

# 进行安装
rabbitmq-plugins enable rabbitmq_delayed_message_exchange

#重启
systemctl restart rabbitmq-server
```





注意找到自己rabbitmq的版本对应的插件，否则安装报错

![image-20230225104631204](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225104631204.png)





![image-20230225104522867](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225104522867.png)



#### 代码架构图

以往延迟信息是基于死信的情况在队列进行处理，插件是在交换机中处理的设置。

> 基于死信

![image-20230225110019293](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225110019293.png)



> 基于插件

![image-20230225110037384](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225110037384.png)



#### 实现案例

> DelayedQueueConfig 配置文件

```java
package com.example.javacode.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.CustomExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;


/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:DelayedQueueConfig
 */

@Configuration
public class DelayedQueueConfig {

    public static final String DELAYED_QUEUE_NAME = "delayed.queue";
    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";
    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";

    @Bean
    public Queue delayedQueue() {
        return new Queue(DELAYED_QUEUE_NAME);
    }

    @Bean
    public CustomExchange delayedExchange() {
        HashMap<String, Object> arguments = new HashMap<>();
        //设置延迟消息的类型为直接类型
        arguments.put("x-delayed-type", "direct");
        
        //设置延迟消息
        return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, arguments);
    }

    @Bean
    public Binding delayedBinding(@Qualifier("delayedQueue") Queue queue, @Qualifier("delayedExchange") CustomExchange customExchange) {

        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();
    }



}

```



> DelayQueueConsumer 消费者

```java
package com.example.javacode.consumer;

import com.example.javacode.config.DelayedQueueConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:DelayQueueConsumer
 */

@Slf4j
@Component
public class DelayQueueConsumer {

    @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)
    public void receiveDelayQueue(Message message) {
        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
        log.info("当前时间：{}，收到的延迟信息：{}", new Date(), msg);
    }
}

```



> 生产者

```java
@GetMapping("/sendDelayMsg/{message}/{ttlTime}")
public void sendMsg(@PathVariable String message, @PathVariable Integer ttlTime) {
    log.info("当前时间{}，发送一条时长{}ms消息给延迟队列：{}", new Date(), ttlTime, message);

    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message, msg -> {
        
        //设置延迟时间,而不是setExpiration过期时间了
        msg.getMessageProperties().setDelay(ttlTime);
        return msg;
    });
}
```



![image-20230225112317170](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225112317170.png)



### 总结

1. 延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ.的特性，如:消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的**解决单点故障问题**，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。
2. 当然，延时队列还有很多其它选择，比如利用Java的DelayQueue，利用Redis.的zsset，利用Quartz(定时器)或者利用kafka的时间轮，这些方式各有特点,看需要适用的场景



## 8.发布确认高级

### 概念

> 介绍

在生产环境中由于一些不明原因，导致 rabbitmq重启，在RabbitMQ重启期间生产者消息投递失败,导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行RabbitMQ的消息可靠投递呢?特别是在这样比较极端的情况，RabbitMQ集群不可用的时候，无法投递的消息该如何处理呢：

![image-20230225121633171](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225121633171.png)



> 实现

1.配置文件:

- NONE：禁用发布确认模式，是默认值
- CORRELATED：发布消息成功到交换器后会触发回调方法
- SIMPLE：经测试有两种效果，
  - 其一效果和CORRELATED值一样会触发回调方法
  - 其二在发布消息成功后使用rabbitTemplate调用waitForConfirms,或 waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDiea方法如果返回false则会关闭channel，则接下来无法发送消息到broker

```yaml
publisher-confirm-type: correlated #(none|simple)
```





> 配置类

```java
package com.example.javacode.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 配置类：发布确认（高级）
@Configuration
public class ConfirmConfig {

    //交换机
    public static final String CONFIRM_EXCHANGE_NAME = "confirm_exchange";
    //队列
    public static final String CONFIRM_QUEUE_NAME = "confirm_queue";
    //RoutingKey
    public static final String CONFIRM_routing_key = "key1";

    //声明交换机
    @Bean
    public DirectExchange confirmExchange() {
        return new DirectExchange(CONFIRM_EXCHANGE_NAME);
    }

    @Bean
    public Queue confirmQueue() {
        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();
    }

    //绑定
    @Bean
    public Binding queueBindingExchange(@Qualifier("confirmQueue") Queue confirmQueue,
                                        @Qualifier("confirmExchange") DirectExchange confirmExchange) {
        return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_routing_key);
    }
}
```



> 消费者代码

```java
package com.example.javacode.consumer;

import com.example.javacode.config.ConfirmConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

// 接收消息
@Slf4j
@Component
public class Consumer {

    @RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)
    public void receiveConfirmMessage(Message message){
        String msg = new String(message.getBody());
        log.info("接受到的队列confirm.queue消息：{}",msg);
    }
}
```



> 生产者代码

```java
package com.example.javacode.controller;

import com.example.javacode.config.ConfirmConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

// 开始发消息 测试确认
@RestController
@Slf4j
@RequestMapping("/confirm")
public class ProducerController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    //发消息
    @GetMapping("/sendMessage/{message}")
    public void sendMessage(@PathVariable String message){
        CorrelationData correlationData = new CorrelationData("1");
        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME
                                      ,ConfirmConfig.CONFIRM_routing_key
                                      ,message,correlationData);
        log.info("发送消息内容：{}",message);
    }
}
```



> 回调接口代码

```java
RabbitTemplate.ConfirmCallback 
```

```java
package com.example.javacode.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:MyCallBacl
 */

@Component
@Slf4j
public class MyCallBacl implements RabbitTemplate.ConfirmCallback {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init() {
        rabbitTemplate.setConfirmCallback(this);
    }

    /**
     *
     * 交换机确认回调方法,发消息后，交换机接收到了就回调
     *   1.1 correlationData：保存回调消息的ID及相关信息
     *   1.2 b:交换机收到消息，为true
     *   1.3 s:失败原因，成功为null
     * 发消息，交换机接受失败，也回调
     *   2.1 correlationData：保存回调消息的ID及相关信息
     *   2.2 b:交换机没收到消息，为false
     *   2.3 s:失败的原因
     */

    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        String Id = correlationData != null ? correlationData.getId() : "";
        if (ack){
            log.info("交换机收到ID为:{}的消息",Id);
        }else {
            log.info("交换机还未收到ID为:{}的消息,原因:{}",Id,cause);
        }
    }
}

```

注意回调接口里面的`CorrelationData`  数据是由生产者传递。

```java
//设置ID为1
CorrelationData correlationData = new CorrelationData("1");

rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME
                              ,ConfirmConfig.CONFIRM_routing_key
                              ,message,correlationData);
```



![image-20230225124021429](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225124021429.png)

> 交换机异常情况（更改交换机名称）

![image-20230225144014763](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225144014763.png)



> 队列异常情况 （更改routingkey）

![image-20230225144624347](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225144624347.png)



### 8.2 回退消息

在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，**如果发现该消息不可路由，那么消息会被直接丢弃**，此时生产者是不知道消息被丢弃这个事件的。通过设置`mandatory`参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。

1.配置文件

```properties
spring.rabbitmq.publisher-returns=true 
# true,false,on,off
```



2.回退接口

```java
RabbitTemplate.ReturnsCallback
```

```java
package com.example.javacode.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.ReturnedMessage;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.nio.charset.StandardCharsets;

/**
 * @Author:wuxie
 * @Date:2023/2/25
 * @Description:(TODO)描述该类
 * @ClassName:MyCallBacl
 */

@Component
@Slf4j
public class MyCallBacl implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init() {
        //注入

        rabbitTemplate.setConfirmCallback(this);

 
        rabbitTemplate.setReturnsCallback(this);
    }

    /**
     * 交换机确认回调方法,发消息后，交换机接收到了就回调
     * 1.1 correlationData：保存回调消息的ID及相关信息
     * 1.2 b:交换机收到消息，为true
     * 1.3 s:失败原因，成功为null
     * 发消息，交换机接受失败，也回调
     * 2.1 correlationData：保存回调消息的ID及相关信息
     * 2.2 b:交换机没收到消息，为false
     * 2.3 s:失败的原因
     */

    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        String Id = correlationData != null ? correlationData.getId() : "";
        if (ack) {
            log.info("交换机收到ID为:{}的消息", Id);
        } else {
            log.info("交换机还未收到ID为:{}的消息,原因:{}", Id, cause);
        }
    }

    
    // 重写回退方法
    @Override
    public void returnedMessage(ReturnedMessage returned) {
        log.error("消息{}，被交换机{}退回，退回原因：{}，路由key：{}",
                  new String(returned.getMessage().getBody(), StandardCharsets.UTF_8),
                  returned.getExchange(),
                  returned.getReplyText(),
                  returned.getRoutingKey());
    }
}

```



> 错写key

![image-20230225145733412](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225145733412.png)



> 错写交换机名称

![image-20230225145817942](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225145817942.png)





### 8.3备份交换机

当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为Fanout。还可以建立一个报警队列，用独立的消费者来进行监测和报警。 

![image-20230225150719655](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225150719655.png)

> 实现

新增一个备用交换机和两个队列

> 配置类代码

```java
配置交换和队列代码同其他一致，主要更改主交换机代码
    
    @Bean
    public DirectExchange confirmExchange() {
    return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(true)
        .withArgument("alternate-exchange", BACKUP_EXCHANGE_NAME).build();
}
```



> 新增消费者代码

```java
@RabbitListener(queues = ConfirmConfig.WARNING_EXCHANGE_NAME)
public void receiveWarningMessage(Message message) {
    String msg = new String(message.getBody());
    log.info("接受到的队列warning.queue消息：{}", msg);
}
```



> 改错发送者代码(routingkey)

```java
rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME
                              ,ConfirmConfig.CONFIRM_routing_key+"哈哈"
                              ,message,correlationData);
```





![image-20230225153135673](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225153135673.png)

> 改错发送者代码(exchangename)

```java
rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME+"哈哈"
                              ,ConfirmConfig.CONFIRM_routing_key
                              ,message,correlationData);
```

![image-20230225153718887](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225153718887.png)



#### 总结

1. 只有不可达目的地的时候（交换机故障），才可以进行回退
2. mandatory参数与备份交换机可以一起使用的时候，如果两者同时开启，`备份交换机优先级高`。





## 9.其他知识

### 9.1幂等性

#### 概念

> 用户对于同一操作发起的一次请求或者多次请求的结果是一致的,不会因为多次点击而产生了副作用。
>
> 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等



#### 解决方法

1. MQ消费者的幂等性的解决一般使用全局ID或者写个唯一标识比如时间戳或者UUID或者订单消费者消费MQ中的消息也可利用MQ的该id来判断，或者可按自己的规则生成一个全局唯一id，每次消费消息时用该id先判断该消息是否已消费过。

2. 在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次,即使我们收到了一样的消息。业界主流的幂等性有两种操作

   - `唯一ID+指纹码机制`

   指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个id是否存在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复;劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。

   - `利用Redis的原子性`

     利用redis执行setnx命令，天然具有幂等性，从而实现不重复消费

### 9.2 优先队列

#### 概念

为消息设置优先级，根据优先级进行降序发送。

redis,只能用List做一个简简单单的消息队列，并不能实现一个优先级的场景。所以使用RabbitMQ进行改造优化，没有设置就默认优先级。



#### 具体案例

![image-20230225162335097](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225162335097.png)



添加参数

```java
//官方允许是0-255之间，此处设置10，允许优化级范围为0-10，不要设置过大，浪费CPU与内存
arguments.put("x-max-priority",10);

//发送的消息设置优先级
AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder().priority(5).build();
channel.basicPublish("", QUEUE_NAME, basicProperties, message.getBytes(StandardCharsets.UTF_8));
```



生产者代码(之前代码进行修改)

```java
package RabbitMQ.Day1;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:生产者
 * @ClassName:Producer
 */

public class Producer {

    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
      
        Channel channel = RabbitMqUtils.createChannel();

        HashMap<String, Object> arguments = new HashMap<>();
        arguments.put("x-max-priority", 10);

        channel.queueDeclare(QUEUE_NAME, false, false, false, arguments);

        
        for (int i = 0; i < 10; i++) {
            String message = "info" + i;
            if (i == 5) {
                AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder().priority(5).build();
                channel.basicPublish("", QUEUE_NAME, basicProperties, message.getBytes(StandardCharsets.UTF_8));
            } else {
                channel.basicPublish("", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));
            }

        }

        System.out.println("消息发送完毕！");
    }

}

```

消费者

```java
package RabbitMQ.Day1;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.TimeoutException;

/**
 * @Author:wuxie
 * @Date:2023/2/23
 * @Description:消费者
 * @ClassName:Consumer
 */

public class Consumer {

    public static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {

      
        Channel channel = RabbitMqUtils.createChannel();

        // 声明 接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            System.out.println(new String(message.getBody()));
        };

        //声明 取消消息
        CancelCallback cancelCallback = consumer -> {
            System.out.println("消息被中断");
        };



        /*
         * 消费者接收消息
         * 参数1：表示消费哪个队列
         * 参数2：消费成功之后，是否需要自动应答，true表示自动应答，false表示手动应答
         * 参数3：消费者成功消费的回调
         * 参数4：消费者取消消费的回调
         */
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}

```





![image-20230225163659686](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225163659686.png)



### 9.3 惰性队列

> 使用场景

惰性队列会尽可能的将消息**存入磁盘中**，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。

即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。

当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。



> 两种模式

队列具备两种模式: default和lazy.默认的为default模式。lazy_模式即为惰性队列的模式，可以通过调用**channel.queueDecare方法的时候在参数中设置**，也可以通过**Policy的方式设置**，如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。



1. 设置 Policy 策略 在 RabbitMQ 中，可以使用 **rabbitmqctl set_policy 命令**来设置一个 Policy。

2. ![image-20230225164945350](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225164945350.png)



3. 

```java
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-queue-mode","lazy");
channel.queueDeclare( "myqueue", false, false, false,args);
```





> 内存开销对比

![image-20230225165421939](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225165421939.png)



在发送1百万务消息，每条消息大概占1KB的情况下，普通队列占用内存是1.2GB,而惰性队列仅仅占用1.5MB(都存在磁盘上了)

根据官方测试数据显示，对于普通队列，如果要发送1千万条消息，需要耗费801秒，平均发送速度约为13000条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是421秒，平均发送速度约为24000条/秒。出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近40MB的空间来发送消息，对于一个 消费者的情况，平均的消费速度约为14000条/秒。





## 10.集群

### 10.1 搭建集群

![image-20230225182800767](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225182800767.png)

1. 克隆三台虚拟机，并且更改主机名，方便后续连接

```sh
vim /etc/hostname
node1
node2
node3
```

2. 修改hosts，使得服务器相互识别

```sh
vim /etc/hosts
IP1 node1
IP2 node2
IP3 node3
```

3. 确保各个节点的cookie文件使用的是同一个值：在node1上执行远程操作命令

   ```sh
   scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie
   
   scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie
   ```

4. 启动rabbitmq，顺带启动Erlang虚拟机和RabbitMQ应用服务，三台节点下执行：

   ```sh
   rabbitmq-server -detached
   ```

5. 进行构成集群链

   节点二

   ```sh
   # rabbitmqctl stop会将Erlang虚拟机关闭  rabbitmqctl stop_app 只关闭rabbitmq服务
   rabbitmqctl stop_app
   rabbitmqctl reset
   rabbitmqctl join_cluster rabbit@node1
   # 只启动rabbitmq服务
   rabbitmqctl start_app
   ```

   节点三

   ```sh
   rabbitmqctl stop_app
   rabbitmqctl reset
   rabbitmqctl join_cluster rabbit@node2
   rabbitmqctl start_app
   ```

6. 查看集群状态

   ```sh
   rabbitmqctl cluster_status
   ```

7. 需要重新设置用户

   ```sh
   # 创建账号
   rabbitmqctl add_user admin 123
   # 设置用户角色
   rabbitmqctl set_user_tags admin administrator
   # 设置用户权限
   rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*" 
   ```

   之后在任意三个节点上的可视化界面登录即可

8. 解除集群节点，node2和nod3分别执行

   ```java
   rabbitmqctl stop_app
   rabbitmqctl reset
   rabbitmqctl start_app
   rabbitmqctl cluster_status
   
   # 此项命令均在node1上执行
   rabbitmqctl forget_cluster_node rabbit@node2
   ```



### 10.2 镜像队列

> 使用场景

集群只有一个主节点，子节点发送的消息创建的队列等都属于主节点。如果主节点发生了异常宕机等问题，那么整个服务就不可用了，也可能导致消息的丢失。

所以将队列镜像到集群中的其他Broker节点上，如果集群中的一个节点失效了，队列能够自动地切换到镜像中的另一个节点上保证服务器的可用性。



> 搭建步骤

![image-20230225184851663](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225184851663.png)

```sh

 Pattern=^mirror # 正则匹配,以mirror为前缀的才可以镜像

ha-mode=exactly 确切的镜像数
ha-params=2 镜像两份(主一份,其他背一份)
ha-sync-mode=automatic 自动开启异步
```



> 效果

![image-20230225185403329](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225185403329.png)



![image-20230225185411911](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225185411911.png)

node1宕机后

![image-20230225185425708](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225185425708.png)



![image-20230225185441320](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225185441320.png)





某一台机器宕机，就会新招一个机器进行备份。就算整个集群只剩下一台机器了，依然能消费队列里面的消息。



### 10.3 实现高可用，负载均衡

![image-20230225205605193](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225205605193.png)

原始方法，如果主节点宕机后，那么整个服务系统就失效了。所以我们需要采取措施，当主节点宕机后，可以连接其他节点进行提供服务，保证系统的可用性。

> 使用Haproxy+Keepalive



> HAProxy.提供高可用性、负载均衡及基于TCPHTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括Twitter,Reddit,StackOverflow,GitHub.在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。
> 扩展nginx,lvs,haproxx.p间的区别: http://www.ha97.com/5646.html



### 10.4 联邦交换机（Federation Exchange）

> 背景

![image-20230225210157987](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225210157987.png)

> 联邦交换机解决，搭建步骤

1. 需要保证每台节点单独运行
2. 在每台机器上开启federation相关插件

```sh
# 每台节点均需执行以下命令
rabbitmq-plugins enable rabbitmq_federation
rabbitmq-plugins enable rabbitmq_federation_management
```

​	3.原理图

![image-20230225210821737](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225210821737.png)

4. 配置上游

![image-20230225212029437](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225212029437.png)

> 配置交换机策略

![image-20230225212145798](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225212145798.png)



> 检查是否成功

![image-20230225212221711](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225212221711.png)



### 10.5 联邦队列

> 背景

同上，数据可以通过交换机进行同步，也可以通过队列进行同步。

联邦队列可以在多个Broker节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求。



![image-20230225212434595](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225212434595.png)



> 搭建步骤

1. 配置上下游（同上交换机）
2. 添加策略

![image-20230225212742918](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225212742918.png)



### 10.6 Shovel（铲子）

> 介绍

上面的联邦队列即本地去拉去远程的数据，而shovel是作为终端将数据转发给其他地方。两个方式的数据操作是相反的。

![image-20230225213115878](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225213115878.png)



> 搭建步骤

1. 开启插件（需要的机器开启）

```sh
rabbitmq-plugins enable rabbitmq_shovel
rabbitmq-plugins enable rabbitmq_shovel_management
```

2. 

![image-20230225215154174](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225215154174.png)

3. 

![image-20230225220322521](
https://wuxie-image.oss-cn-chengdu.aliyuncs.com/2023/04/02/image-20230225220322521.png)
